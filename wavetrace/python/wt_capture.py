# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""Wavetrace Capture Module

This module communicates with a Wavetrace FPGA instance via a serial port. It is
used to set trigger conditions, initiate captures, and read back captured data.
The captured data can be saved to a .vcd file, which can be viewed in a waveform
viewer such as GTKWave.

  Typical usage example:

  import wt_capture
  wt = WTCapture("/dev/ttyUSB3", "/wt_output/signal_list.txt")
  wt.add_trigger("instance.dout_valid[0]", 1)
  wt.add_trigger("instance.count[3:0]", 0xF)
  wt.capture()

"""
import sys
import serial
import struct
import time
import wt_util as util

OUTPUT_DIR = "output/"

class WTCapture(object):
  """Provides a set of high level functions to interact with a Wavetrace FPGA
  instance via a serial port.
  """
  # Fixed register addresses within Wavetrace Verilog module
  REG_WHO_AM_I        = 0   # RO: readable register containing 0xABCD1234
  REG_CAPT_DEPTH      = 1   # RO: CaptDepth parameter
  REG_PRE_TRIG_DEPTH  = 2   # RO: PreTrigDepth paramater
  REG_DATA_BITS       = 3   # RO: DataBits paramater
  REG_CLOCK_HZ        = 4   # RO: ClockHz parameter
  REG_TRIG_MODE       = 5   # RW: trigger mode: 0=none, 1=single, 2=continuous
  REG_TRIG_COUNT      = 6   # RW: number of times trigger has been hit, write 0 to clear
  REG_CAPT_COUNT      = 7   # RW: number of times capture has completed, write 0 to clear
  REG_SUB_SAMPLE      = 8   # RW: sub-samples the captured data by this ratio before storing
  REG_GO              = 9   # RW: enables capture sequence
  REG_CAPT_STATE      = 10  # RO: capture state
  REG_TRIG_SETUP_BASE = 16  # RW: start of trigger setup regs, addresses depend on DataBits
  WHO_AM_I_VAL = 0xABCD1234

  # Trigger Modes
  TRIG_MODE_NONE       = 0
  TRIG_MODE_SINGLE     = 1
  TRIG_MODE_CONTINUOUS = 2

  # Relevant Capture States
  CAPTURING_STATE = 3

  # string constants
  RISE_EDGE = "rising_edge"
  FALL_EDGE = "falling_edge"
  LOW       = 0
  HIGH      = 1

  def __init__(self, serial_port, signal_list_filename, uart_baud=115200):
    """WTCapture Constructor
    Args:
      serial_port: the serial port connected to the FPGA's wavetrace uart,
        example "/dev/ttyUSB2"
      signal_list_filename: the filename containing the list of signals
        being debugged, this should be generated by the wt_route.py tool.
    """
    self.comm = serial.Serial(serial_port, uart_baud, timeout=1)
    self.signal_list = self._read_signal_list(signal_list_filename)

    # check we can read the who-am-i regster
    if self.reg_read(self.REG_WHO_AM_I) != self.WHO_AM_I_VAL:
      util.error("Unable to read 'whoami' register from hardware")

    # read various parameters from the hardware module
    self.capture_depth = self.reg_read(self.REG_CAPT_DEPTH)
    self.pre_trig_depth = self.reg_read(self.REG_PRE_TRIG_DEPTH)
    self.data_bits = self.reg_read(self.REG_DATA_BITS)
    self.clock_speed = self.reg_read(self.REG_CLOCK_HZ)
    self.sub_sampling_ratio = 1

    # check the hardware's data width matches what is in the signal list
    sig_width = 0
    for (s_net, s_width) in self.signal_list:
      sig_width += s_width
    if sig_width != self.data_bits:
      util.error("Mismatch between data width the in signal list '%s' (%d bits)\n"
                 "       and what is actually implemented in the hardware (%d bits)." %
                 (signal_list_filename, sig_width, self.data_bits))

    # number of trigger registers and capture memory base address
    # depend on data width
    self.num_banks = (self.data_bits + 31) / 32
    self.trig_regs = self.num_banks
    print "num banks = %d" % self.num_banks
    bank_bits = util.clog2(self.num_banks)
    self.capture_memory_base = self.capture_depth << bank_bits

    print ""
    print "Read parameters from hardware"
    print "Capture depth:  %d" % self.capture_depth
    print "Pre-Trig depth: %d" % self.pre_trig_depth
    print "Data bits:      %d" % self.data_bits
    print "Clock hertz:    %d" % self.clock_speed
    print ""

    self.trigger_mask1  = [0] * self.trig_regs
    self.trigger_mask2  = [0] * self.trig_regs
    self.trigger_value1 = [0] * self.trig_regs
    self.trigger_value2 = [0] * self.trig_regs
    self.qualifier_mask = [0] * self.trig_regs
    self.qualifier_value = [0] * self.trig_regs

  def _read_signal_list(self, filename):
    """Reads a list of signal names from a file and extracts the signal
    width from each name.
    Args:
      filename: the filename containing the signal list, should be output
                by wt_router.py
    Returns:
      A list containing ('signal_name', 'signal_width') pairs
    """
    fp = open(filename, "r")
    sigs = []
    for line in fp:
      sig_name = line.strip()
      width = util.net_width(sig_name)
      sigs.append([sig_name, width])
    fp.close
    return sigs

  def _unpack_as_bytes(self, list_of_uints):
    """Helper function to unpack a list of unsigned integers as a list of
    unsigned bytes"""
    return struct.unpack("B"*4*len(list_of_uints),
                         struct.pack("I"*len(list_of_uints),
                                     *list_of_uints))

  def reg_write(self, addr, data):
    """Writes data to an FPGA address using the serial port
    Args:
      addr: address within the fpga Wavetrace module
      data: 32-bit data to write to the register
    """
    word_addr = addr << 2
    msg_bytes = self._unpack_as_bytes([0xABCDA000, word_addr, data])
    self.comm.write(bytearray(msg_bytes))

  def reg_read(self, addr):
    """Reads data from an FPGA address using the serial port
    Args:
      addr: register address within the fpga Wavetrace module
    Returns:
      register data
    """
    byte_addr = addr << 2;
    msg_bytes = self._unpack_as_bytes([0xABCDB001, byte_addr])
    self.comm.write(bytearray(msg_bytes))
    rx_str = ""
    for i in xrange(4):
      ch = self.comm.read(1)
      if len(ch) > 0:
        rx_str += ch
      else:
        util.error("Did not get response from FPGA while reading address 0x%x\n"
                   "Please check the *clock speed* is correct in the setup script "
                   "and that the *UART pins* are assigned." % addr)
    rx_data = struct.unpack("I", rx_str)
    return rx_data[0]

  def reg_read_burst(self, addr, burst_size):
    """Reads a burst of data from the specifiedd FPGA address using the
       serial port.
    Args:
      addr: register address witin the FPGA Wavetrace module
    Returns:
      a list of data containing 'burst_size' 32-bit data words
    """
    byte_addr = addr << 2;
    if (burst_size > 255):
      util.error("Invalid burst size %d for register read." % burst_size)
    read_cmd = 0xABCDB000 + burst_size
    msg_bytes = self._unpack_as_bytes([read_cmd, byte_addr])
    self.comm.write(bytearray(msg_bytes))
    burst_data = []
    for b in xrange(burst_size):
      rx_str = ""
      for i in xrange(4):
        ch = self.comm.read(1)
        if len(ch) > 0:
          rx_str += ch
        else:
          util.error("Did not get response from FPGA while reading address 0x%x\n"
                     "Please check the *clock speed* is correct in the setup script "
                     "and that the *UART pins* are assigned." % addr)
      rx_data = struct.unpack("I", rx_str)
      burst_data.append(rx_data[0])
    return burst_data

  def write_trig_mode(self, mode):
    self.reg_write(self.REG_TRIG_MODE, mode)

  def read_trig_mode(self):
    return self.reg_read(self.REG_TRIG_MODE)

  def write_sub_sampling(self, ratio):
    self.reg_write(self.REG_SUB_SAMPLE, ratio)

  def read_sub_sampling(self):
    return self.reg_read(self.REG_SUB_SAMPLE)

  def read_trig_count(self):
    return self.reg_read(self.REG_TRIG_COUNT)

  def read_capt_count(self):
    return self.reg_read(self.REG_CAPT_COUNT)

  def read_capt_state(self):
    return self.reg_read(self.REG_CAPT_STATE)

  def _write_reg_array(self, base_addr, array):
    for i in range(len(array)):
      self.reg_write(base_addr + i, array[i])

  def write_trig_mask1(self, mask):
    self._write_reg_array(self.REG_TRIG_SETUP_BASE, mask)

  def write_trig_mask2(self, mask):
    self._write_reg_array(self.REG_TRIG_SETUP_BASE +
                          self.trig_regs, mask)

  def write_trig_value1(self, value):
    self._write_reg_array(self.REG_TRIG_SETUP_BASE +
                          2*self.trig_regs, value)

  def write_trig_value2(self, value):
    self._write_reg_array(self.REG_TRIG_SETUP_BASE +
                          3*self.trig_regs, value)

  def write_qualifier_mask(self, mask):
    self._write_reg_array(self.REG_TRIG_SETUP_BASE +
                          4*self.trig_regs, mask)

  def write_qualifier_value(self, value):
    self._write_reg_array(self.REG_TRIG_SETUP_BASE +
                          5*self.trig_regs, value)


  def _find_net_position(self, net):
    """Checks if the net exists in the signal list and returns the bit
       position of the net's LSB within the overall vector of concatenated
       signals"""

    # extract the range from the net's name
    (net_range_hi, net_range_lo) = util.net_range(net)

    # match the trigger's net name against our list of captured signals
    found = False
    bit_pos = 0
    for (s_net, s_width) in self.signal_list:
      if util.net_name(net) == util.net_name(s_net):
        # check range is valid
        (s_range_hi, s_range_lo) = util.net_range(s_net)
        if (net_range_hi > s_range_hi or net_range_lo < s_range_lo):
          util.error("Net bits on signal '%s' do not lie within captured"
                " bits on signal '%s'" % (net, s_net))
        bit_pos += net_range_lo - s_range_lo
        found = True
        break
      else:
        bit_pos += s_width

    if not found:
      util.error("Cannot find signal '%s' in the signal list" % net)

    return bit_pos

  def _set_bits_in_reg_array(self, value, pos, width, array):
    """Sets a range of bits within an array of 32-bit values, as
    if the array were treated as a continuous bit vector.
    Args:
      value: the value to set the specified bits to
      pos: the position of the LSB within the range of bits to be set
      width: the width of the bit range being set
      array: reference to an array of 32-bit values
    """
    # TODO: consider using a string to store this data instead of an
    # array of integers, might make things simpler

    # determine which 32-bit registers this vector overlaps with
    bank_start  = pos / 32
    bank_end    = (pos + width) / 32
    bank_offset = pos % 32

    if (bank_start == bank_end):
      array[bank_start] |= (value << bank_offset)
    else:
      vector64 = array[bank_end] << 32 | array[bank_start]
      vector64 |= (value << bank_offset)
      array[bank_start] = vector64 & 0xFFFFFFFF
      array[bank_end] = (vector64 >> 32) & 0xFFFFFFFF

  def add_trigger(self, trig_net, trig_value):
    """Adds a trigger to be used for the next capture.
    Args:
      trig_net: the net name and bits for the trigger, for example
       "inst_0.counter[7:4]"
      trig_value: either a value, or a string constant, indicating the value
       required on the 'trig_net' for the trigger to fire. A 'rising_edge' or
       'falling_edge' string can be  used to trigger on either a rising or
       falling edge instead of a value.
    """
    # The hardware performs two masked comparisons for the trigger detection,
    # allowing us to detect rising and falling edges. For each new trigger
    # condition, we need to set the appropriate mask and value bits within
    # an array of 32-bit registers represending the trigger mask and
    # comparison vectors

    # TODO: enforce bit range for non single bit vectors, compare
    #       net name against signal list to decide if it is a vector
    bit_pos   = self._find_net_position(trig_net)
    bit_width = util.net_width(trig_net)
    bit_mask  = (1 << bit_width) - 1

    if isinstance(trig_value, basestring):
      if trig_value in (self.RISE_EDGE, self.FALL_EDGE):
        self._set_bits_in_reg_array(bit_mask, bit_pos, bit_width,
                                    self.trigger_mask1)
        self._set_bits_in_reg_array(bit_mask, bit_pos, bit_width,
                                    self.trigger_mask2)
        val1 = 0 if trig_value == self.RISE_EDGE else 1
        val2 = 1 if trig_value == self.RISE_EDGE else 0
        self._set_bits_in_reg_array(val1, bit_pos, bit_width,
                                    self.trigger_value1)
        self._set_bits_in_reg_array(val2, bit_pos, bit_width,
                                    self.trigger_value2)
      else:
        util.error("Invalid trigger value '%s' specified for net '%s'" %
                   (trig_value, trig_net))
    else:
      self._set_bits_in_reg_array(bit_mask, bit_pos, bit_width,
                                  self.trigger_mask2)
      self._set_bits_in_reg_array(trig_value, bit_pos, bit_width,
                                    self.trigger_value2)

  def add_qualifier(self, qual_net, qual_value):
    """Adds a storage qualifier to be used for the next capture
    Args:
      qual_net: the net name and bits for the storage qualifier, for example
        "inst_0.counter[0]"
      qual_value: the value the 'qual_net' must match in order for the sample to
         be stored.
    """
    bit_pos   = self._find_net_position(qual_net)
    bit_width = util.net_width(qual_net)
    bit_mask  = (1 << bit_width) - 1

    self._set_bits_in_reg_array(bit_mask, bit_pos, bit_width,
                                self.qualifier_mask)

    self._set_bits_in_reg_array(qual_value, bit_pos, bit_width,
                                self.qualifier_value)


  def set_sub_sampling(self, ratio):
    """Set ratio of sub-sampling for data captured after all storage qualifiers
      have been applied. This allows a trade-off between captured depth and
      captured resolution.
    Args:
      ratio: the subsampling ratio, '1' will capture all samples, a ratio of
      '2' will capture every second sample, etc.
    """
    self.sub_sampling_ratio = ratio

  def start_capture(self):
    """Starts the capture sequence. The capture count will be incremented
    when the capture seqeuence completes. Call 'stop_capture' before
    starting the next capture."""
    self.reg_write(self.REG_GO, 1)

  def stop_capture(self):
    """Stops the current capture being performed by the FPGA. This can be
    done during or after a sequence has completed. It should be called
    before the next capture can be started."""
    self.reg_write(self.REG_GO, 0)

  def read_capture_data(self):
    """Reads the capture memory from the FPGA.
    Returns: a 2D list containing the captured data for each memory
             bank for each cycle.
    """
    capt_data = [[] for b in xrange(self.num_banks)]
    capt_addr_bits = util.clog2(self.capture_depth)
    for bank in xrange(self.num_banks):
      word_addr = self.capture_memory_base + (bank << capt_addr_bits)
      remain = self.capture_depth
      while remain > 0:
        burst_size = min(128, remain)
        capt_data[bank].extend(self.reg_read_burst(word_addr, burst_size))
        remain -= burst_size
        word_addr += burst_size

      print "%d%% complete" % ((bank + 1) * 100 / self.num_banks)

    return capt_data

  def output_vcd_file(self, capt_data, signal_list):
    """Writes a '.vcd' waveform file showing cycle-by-cycle data for a list
    of signals so that they may be viewed by a waveform viewer.
    Args:
      capt_data: A 2D list containing the captured data for each memory
                 bank for each cycle.
      signal_list: A list of signals represented by the data.
    """
    fp  = open(OUTPUT_DIR + "/wavedump.vcd",  "w")
    steps_per_cycle = 10
    clock_period_ps = 1.0e12 / self.clock_speed
    timescale_ps = int(clock_period_ps / steps_per_cycle) * self.sub_sampling_ratio

    print >> fp, "$timescale %dps $end" % timescale_ps
    # add a sample-clock and sample-count signal to the waveform
    print >> fp, "$var wire 1 sample_clock sample_clock $end"
    print >> fp, "$var integer 32 sample_count sample_count $end"

    for sig in signal_list:
      (name, width) = (sig[0], sig[1])
      print >> fp, "$var wire %d %s %s $end" % (width, name, name)
    print >> fp, "$enddefinitions $end"

    sample_count = -self.pre_trig_depth
    for i in xrange(len(capt_data[0])):
      print >> fp, "#%d" % (i*steps_per_cycle) # time step
      print >> fp, "1sample_clock"
      print >> fp, "b%s %s" % ("{0:b}".format(sample_count & 0xFFFFFFFF),
                                 "sample_count")
      # loop through all signals and extract bits from the data vector
      pos = 0
      for sig in signal_list:
        (name, width) = (sig[0], sig[1])

        # determine which memory bank(s) this vector comes from
        bank_start = pos / 32
        bank_end = (pos + width - 1) / 32

        # build up a binary string for the data vector by concatenating the
        # data segments from each bank
        bin_str = ""
        for b in xrange(bank_start, bank_end + 1):
          start_pos = pos % 32 if b == bank_start else 0
          end_pos = (pos + width - 1) % 32 if b == bank_end else 31
          seg_width = end_pos - start_pos + 1
          data_seg = (capt_data[b][i] >> start_pos) & ((1 << seg_width) - 1)
          # add to the front of the binary string since we're going from LSB first
          bin_str = "{0:b}".format(data_seg).zfill(seg_width) + bin_str

        print >> fp, "b%s %s" % (bin_str, name)
        pos += width

      print >> fp, "#%d" % (i*steps_per_cycle + steps_per_cycle / 2) # time step
      print >> fp, "0sample_clock"
      sample_count += self.sub_sampling_ratio
    fp.close()

  def output_gtkw_file(self, signal_list):
    """Writes a '.gtkw' file which can be passed to the GTKWave tool to
    automatically show all signals in the waveform viewer and set a vertical
    bar marking the trigger position.
    Args:
      signal_list: a list of the signals represented by the captured data.
    """
    clock_period_ps = 1.0e12 / self.clock_speed
    vert_marker = self.pre_trig_depth * clock_period_ps * self.sub_sampling_ratio

    # Note: to figure out what needs to go in this file, you can open GTKWave,
    #       configure the view, and then save the setup commands via
    #       File->'Write Save File'
    fp = open(OUTPUT_DIR + "/wavedump.gtkw", "w")
    print >> fp, "[timestart] 0"
    print >> fp, "[size] 1700 600"
    print >> fp, "[pos] -1 -1"
    print >> fp, ("*-20.000000 %d %d -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 "
                  " -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1" %
                  (vert_marker, vert_marker))
    print >> fp, "@28"
    print >> fp, "sample_clock"
    print >> fp, "@421"
    print >> fp, "sample_count"
    print >> fp, "@200"
    print >> fp, "-"
    print >> fp, "@22"
    for sig in signal_list:
      # hierarchical nets need a '\' before them
      if "." in sig[0]:
        print >> fp, "\\"+sig[0]
      else:
        print >> fp, sig[0]
    print >> fp, "[pattern_trace] 1"
    print >> fp, "[pattern_trace] 0"
    fp.close()

  def capture(self, trigger_mode=TRIG_MODE_SINGLE):
    """Performs the Wavetrace capture seqeunce:
      - stops any pending captures
      - sets the trigger conditions
      - enables the capture
      - waits for the trigger to be hit and the capture to compelte
      - reads the captured data
      - writes waveform file and GTKWave config file
    Args:
      trig_mode: trigger mode, see TRIG_MODE class constants for options,
                 when this is set to TRIG_MODE_NONE:
                  - if there are no triggers we use TRIG_MODE_NONE
                  - if there are any triggers we use TRIG_MODE_SINGLE
    """
    self.stop_capture()
    # we monitor the capture count to determine when the capture has
    # completed.
    capt_count = self.read_capt_count()
    trig_count = self.read_trig_count()

    if all(m == 0 for m in self.trigger_mask2):
      mode = self.TRIG_MODE_NONE
    else:
      mode = trigger_mode

    print "using trigger mode: ", mode
    self.write_trig_mode(mode)

    self.write_trig_mask1(self.trigger_mask1)
    self.write_trig_mask2(self.trigger_mask2)
    self.write_trig_value1(self.trigger_value1)
    self.write_trig_value2(self.trigger_value2)

    self.write_qualifier_mask(self.qualifier_mask)
    self.write_qualifier_value(self.qualifier_value)
    self.write_sub_sampling(self.sub_sampling_ratio)

    print "capture count = %d" % self.read_capt_count()
    print "trigger count = %d" % self.read_trig_count()
    print "trig mode = %d" % self.read_trig_mode()
    print "sub-sampling = %d" % self.read_sub_sampling()

    def print_reg_array(label, base):
      print label + "\t",
      for i in reversed(xrange(self.trig_regs)):
        print "%08x " % self.reg_read(base + i),
      print ""

    print_reg_array("trig_mask1",  self.REG_TRIG_SETUP_BASE)
    print_reg_array("trig_mask2",  self.REG_TRIG_SETUP_BASE +   self.trig_regs)
    print_reg_array("trig_value1", self.REG_TRIG_SETUP_BASE + 2*self.trig_regs)
    print_reg_array("trig_value2", self.REG_TRIG_SETUP_BASE + 3*self.trig_regs)

    print_reg_array("qual_mask",   self.REG_TRIG_SETUP_BASE + 4*self.trig_regs)
    print_reg_array("qual_value",  self.REG_TRIG_SETUP_BASE + 5*self.trig_regs)


    self.start_capture()

    if mode == self.TRIG_MODE_NONE:
      # wait for capture to complete
      print "waiting for capture to complete..."
      while (self.read_capt_count() == capt_count):
        pass
    elif mode == self.TRIG_MODE_SINGLE:
      print "waiting for trigger...."
      while (self.read_trig_count() == trig_count):
        pass
      # wait for capture to complete
      print "triggered, waiting for capture to complete..."
      while (self.read_capt_count() == capt_count):
        pass
    elif mode == self.TRIG_MODE_CONTINUOUS:
      # wait for at least one trigger
      print "waiting for trigger...."
      while (self.read_trig_count() == trig_count):
        pass
      trig_count += 1
      print "trigger hit once"
      # TODO: give user more control, wait for keypress to do capture?
      timeout = 10.0  # wait for an interval with no new triggers
      start = time.time()
      while (time.time() - start < timeout):
        # restart the timeout every time there is a new trigger
        if (self.read_trig_count() > trig_count):
          trig_count = self.read_trig_count()
          start = time.time()
          print "trigger hit again (%d times)" % trig_count
      # wait for the final capture to complete
      # TODO: use this method instead of checking capt_count above?
      print "timed out, waiting for capture to complete"
      while (self.read_capt_state() == self.CAPTURING_STATE):
        pass

    print "capture done, reading data..."
    capt_data = self.read_capture_data()
    for b in xrange(len(capt_data)):
      print "----- Pre Trigger Data (memory bank %d) ------" % b
      for i in xrange(len(capt_data[b])):
        if i == self.pre_trig_depth:
          print "----- Post Trigger Data (memory bank %d) ------" % b
        print "0x%x" % (capt_data[b][i] & 0xFFFF),
        if ((i+1)%16==0):
          print ""

    self.output_vcd_file(capt_data, self.signal_list)
    self.output_gtkw_file(self.signal_list)
